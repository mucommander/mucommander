<!--
This file is part of muCommander, http://www.mucommander.com
Copyright (C) 2002-2007 Maxence Bernard

muCommander is free software; you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation; either version 3 of the License, or
(at your option) any later version.

muCommander is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

You should have received a copy of the GNU General Public License
along with this program.  If not, see <http://www.gnu.org/licenses/>.
-->

<!-- ========================================================= -->
<!-- Defines muCommander specific targets.                     -->
<!--                                                           -->
<!-- ========================================================= -->
<project>
  <!-- = Task loading ======================================== -->
  <!-- ======================================================= -->
  <!-- Loads the javaw task.                                   -->
  <target name="load-javaw" depends="tools-compress">
    <taskdef name="javaw" classname="com.mucommander.ant.java.JavaTask" classpath="${tools.jar.cmp}"/>
  </target>

  <!-- Loads the mksize task.                                  -->
  <target name="load-mksize" depends="tools-compress">
    <taskdef name="mksize" classname="com.mucommander.ant.util.SizeTask" classpath="${tools.jar.cmp}"/>
  </target>

  <!-- Loads the mkapp task.                                   -->
  <target name="load-mkapp" depends="tools-compress">
    <taskdef name="mkapp" classname="com.mucommander.ant.macosx.AppTask" classpath="${tools.jar.cmp}"/>
  </target>

  <!-- Loakds the mkjnlp task.                                 -->
  <target name="load-mkjnlp" depends="tools-compress">
    <taskdef name="mkjnlp" classname="com.mucommander.ant.jnlp.JnlpTask" classpath="${tools.jar.cmp}"/>
  </target>



  <!-- = Resources generation ================================ -->
  <!-- ======================================================= -->

  <!-- Copies the project's resources.                         -->
  <!-- All resources will be copied in ${classes.normal}.      -->
  <target name="resources">
    <echo>Copying resources...</echo>
    <!-- Copies the images.                                    -->
    <copy todir="${classes.normal}" overwrite="true">
      <fileset dir="${res.images}">
        <include name="**/*"/>
      </fileset>
    </copy>

    <!-- Copies misc. data files.                              -->
    <copy file="${res.dictionary}"        tofile="${classes.normal}/dictionary.txt" overwrite="true"/>
    <copy file="${res}/mime.types"        todir="${classes.normal}" overwrite="true"/>
    <copy file="${res}/toolbar.xml"       todir="${classes.normal}" overwrite="true"/>
    <copy file="${res}/command_bar.xml"   todir="${classes.normal}" overwrite="true"/>
    <copy file="${res}/action_keymap.xml" todir="${classes.normal}" overwrite="true"/>
    <copy file="${res.license}"           tofile="${classes.normal}/license.txt" overwrite="true"/>

    <!-- Generates the themes.                                 -->
    <echo>Creating themes...</echo>
    <mkdir dir="${classes.normal}/${themes.out}"/>
    <copy todir="${classes.normal}/${themes.out}" overwrite="true">
      <fileset dir="${themes.in}">
        <include name="**/*.xml"/>
      </fileset>
    </copy>
  </target>



  <!-- = External libraries management ======================= -->
  <!-- ======================================================= -->
  <!-- The following tasks are used manage the various the     -->
  <!-- various external libraries used by muCommander.         -->

  <!-- Checks whether the external libraries are up to date.   -->
  <target name="check-libs" unless="libs.up-to-date">
    <uptodate property="libs.up-to-date" targetfile="${jar.normal}">
      <srcfiles dir="${lib}" includes="**/*.jar"/>
    </uptodate>
  </target>

  <!-- Includes the application's libraries with its binaries. -->
  <!-- All libraries will be unpacked in ${classes.normal}.    -->
  <target name="include-libs" depends="check-libs" unless="libs.up-to-date">
    <echo>Unpacking external libraries...</echo>
    <unjar dest="${classes.normal}">
      <fileset dir="${lib}/include">
        <include name="*.jar"/>
    </fileset>
    </unjar>

    <!-- Makes sure that muCommander's JAR file does not       -->
    <!-- inherit license and copyright from libraries.         -->
    <delete dir="${classes.normal}/META-INF"/>

    <!-- Makes sure that library documentation doesn't get     -->
    <!-- included in the final jar.                            -->
    <delete includeemptydirs="true">
      <fileset dir="${classes.normal}" includes="**/*.html"/>
      <fileset dir="${classes.normal}" includes="**/*.css"/>
      <fileset dir="${classes.normal}" includes="**/*.gif"/>
    </delete>

    <!-- Deletes unused JCifs resouces.                        -->
    <delete file="${classes.normal}/jcifs/util/mime.map"/>
  </target> 



  <!-- = Name generation ===================================== -->
  <!-- ======================================================= -->

  <!-- Generates the package-prefix for nightly builds.        -->
  <target name="nightly-prefix" if="is-nightly">
    <echo>Creating nightly package name prefix...</echo>
    <property name="package-prefix" value="mucommander-current"/>
  </target>

  <!-- Generates the package-prefix for non-nightly builds.    -->
  <target name="release-prefix" depends="load-strreplace" unless="is-nightly">
    <echo>Creating release package name prefix...</echo>
    <strreplace from="mucommander-${app.version}${app.subversion}" to="package-prefix" what="[ .]" with="_"/>
  </target>

  <!-- Generates the current build's package prefix.           -->
  <!-- The package prefix will be stored in ${package-prefix}, -->
  <!-- and depends on whether we're compiling a nightly build  -->
  <!-- or an official release one.                             -->
  <target name="package-prefix" depends="nightly-prefix,release-prefix"/>

  <!-- Generates the prefix folder for all archives.           -->
  <!-- Output will be stored in property ${archive-prefix}.    -->
  <target name="archive-prefix" depends="load-strreplace">
    <echo>Creating archive prefix...</echo>
    <!-- Escapes the version number for the TGZ prefix.        -->
    <strreplace from="muCommander-${app.version}${app.subversion}" to="archive-prefix" what="[ .]" with="_"/>
  </target>



  <!-- = Compilation targets ================================= -->
  <!-- ======================================================= -->
  <!-- The following targets are used to generate the clear    -->
  <!-- muCommander JAR file.                                   -->
  <!-- The only target that should be referenced is 'jar', as  -->
  <!-- the other ones are only helper targets.                 -->


  <!-- Creates the runtime constant class.                     -->
  <!-- Output will be stored in ${tmp.source}.                 -->
  <target name="constants" depends="load-javaw">
    <tstamp/>
    <echo>Creating runtime constants...</echo>
    <mkdir dir="${tmp.source}"/>
    <property name="is-debug"    value="true"/>
    <property name="version-url" value="${url.app-version}"/>
    <javaw name="${tmp.source}/com.mucommander.RuntimeConstants">
      <field name="DEBUG"               value="${is-debug}"    type="boolean"/>
      <field name="VERSION"             value="${app.version}${app.subversion}"/>
      <field name="COPYRIGHT"           value="${app.copyright}"/>
      <field name="LICENSE"             value="/license.txt"/>
      <field name="APP_STRING"          value="muCommander v${app.version}${app.subversion}"/>
      <field name="VERSION_URL"         value="${version-url}"/>
      <field name="RELEASE_DATE"        value="${DSTAMP}" type="String"/>
      <field name="HOMEPAGE_URL"        value="${url.homepage}"/>
      <field name="FORUMS_URL"          value="${url.forums}"/>
      <field name="DONATION_URL"        value="${url.donation}"/>
      <field name="DICTIONARY_FILE"     value="/dictionary.txt"/>
      <field name="THEMES_PATH"         value="${themes.out}"/>
      <field name="BUG_REPOSITORY_URL"  value="${url.bug-repository}"/>
      <field name="DEFAULT_THEME"       value="Native"/>
    </javaw>
  </target>

  <!-- Compiles all java files found in ${source} and          -->
  <!-- ${tmp.source}, and stores the resulting bytecode in     -->
  <!-- {$classes.normal}.                                      -->
  <target name="compile" depends="constants">
    <echo>Compiling sources...</echo>
    <mkdir dir="${classes.normal}"/>
    <javac destdir="${classes.normal}" debug="on" deprecation="on"
           encoding="utf-8" source="${app.jvm}" target="${app.jvm}" excludes="com/mucommander/ant/**">
      <src path="${source}"/>
      <src path="${tmp.source}"/>
      <!-- Includes the application's libraries in the         -->
      <!-- classpath.                                          -->
      <classpath>
         <fileset dir="${lib}">
           <include name="*include/*.jar"/>
         </fileset>
      </classpath>
    </javac>
  </target>

  <!-- Generates the application's uncompressed, unobfuscated  -->
  <!-- JAR file.                                               -->
  <!-- Output will be stored in {$jar.normal}.                 -->
  <target name="jar" depends="compile,include-libs,resources">
    <tstamp/>
    <echo>Creating JAR file...</echo>
    <jar jarfile="${jar.normal}" basedir="${classes.normal}" excludes="**/*Test.class">
      <manifest>
        <attribute name="Main-Class"             value="${app.main}"/>
        <attribute name="Specification-Title"    value="muCommander"/>
        <attribute name="Specification-Vendor"   value="Maxence Bernard"/>
        <attribute name="Specification-Version"  value="${app.version}"/>
        <attribute name="Implementation-Title"   value="muCommander"/>
        <attribute name="Implementation-Vendor"  value="Maxence Bernard"/>
        <attribute name="Implementation-Version" value="${app.version}${app.subversion} ${DSTAMP}"/>
      </manifest>
    </jar>
  </target>



  <!-- = Obfuscation targets ================================= -->
  <!-- ======================================================= -->
  <!-- The following targets are used to obfuscate the         -->
  <!-- muCommander bytecode.                                   -->
  <!-- The only target that should be refered is 'obfuscate',  -->
  <!-- as all the other ones are used to figure out the best   -->
  <!-- obfuscation policy.                                     -->

  <!-- Copies ${jar.normal} to ${jar.obf}.                     -->
  <!-- This target is meant to be used when it was not         -->
  <!-- to load the proGuard task.                              -->
  <target name="copy-bytecode" unless="proguard.available">
    <echo>proGuard unavailable, skipping obfuscation...</echo>
    <copy file="${jar.normal}" tofile="${jar.obf}" overwrite="true"/>
  </target>

  <!-- Obfuscates the clear JAR file and stores the result in  -->
  <!-- ${jar.obf}.                                             -->
  <target name="obfuscate-bytecode" depends="load-libpath" if="proguard.available">
    <echo>Creating obfuscated JAR file...</echo>
    <mkdir dir="${reports.main}"/>
    <proguard overloadaggressively="false" usemixedcaseclassnames="${proguard.mixed-case}" ignorewarnings="false" optimize="true" shrink="true" obfuscate="true"
              printmapping="${tmp.compile}/obfuscate.map" printusage="${proguard.reports}" printseeds="${tmp.compile}/obf-seeds.txt"
              allowaccessmodification="false" repackageclasses="" skipnonpubliclibraryclasses="true" target="${app.jvm}">
      <injar name="${jar.normal}"/> 
      <outjar name="${jar.obf}"/>

      <libraryjar path="${java.lib}"/>
      <libraryjar name="${lib}/noinclude" jarfilter="*.jar"/>

      <keepattribute name="exceptions"/>

      <!-- Action API uses reflection                          -->
      <keepclasseswithmembers extends="com.mucommander.ui.action.MuAction">
        <constructor access="public" name="*"/>
      </keepclasseswithmembers>
      <!-- Yanfs uses reflection                               -->
      <keep name="com.sun.nfs.XFileAccessor"/>
      <keep name="com.sun.nfs.XFileExtensionAccessor"/>
      <!-- Main class                                          -->
      <keep name="${app.main}">
	<method access="public static" type="void" name="main" parameters="java.lang.String[]"/>
      </keep>
      <!-- Class loader                                        -->
      <keep name="${app.loader}">
        <field access="public,protected"/>
        <method access="public,protected"/>
        <constructor access="public,protected"/>
      </keep>
    </proguard>
  </target>

  <!-- Generates the application's obfuscated jar file.        -->
  <!-- Output will be stored in ${jar.obf}.                    -->
  <target name="obfuscate" depends="disable-debug,clean,jar,load-proguard,copy-bytecode,obfuscate-bytecode"/>



  <!-- = Compression targets ================================= -->
  <!-- ======================================================= -->
  <!-- The following targets are used to compress the final    -->
  <!-- JAR file.                                               -->
  <!-- The only target that should be referenced is 'compress' -->
  <!-- as the other ones are meant to identify the best        -->
  <!-- compression policy.                                     -->

  <!-- Copies ${jar.obf} over ${jar.cmp}.                      -->
  <!-- This target is meant to be used when 7za is found not   -->
  <!-- to be available.                                        -->
  <target name="copy-obfuscated" unless="7za.available">
    <echo>7za unavailable, using standard compression...</echo>
    <copy file="${jar.obf}" tofile="${jar.cmp}"/>
  </target>

  <!-- Compress the content of ${jar.obf} into ${jar.cmp}.     -->
  <!-- This target is meant to be used when 7za is found to be -->
  <!-- available.                                              -->
  <target name="compress-obfuscated" if="7za.available">
    <echo>Compressing JAR file...</echo>
    <mkdir dir="${dist}"/>
    <unjar src="${jar.obf}" dest="${classes.obf}"/>
    <exec executable="${7za.executable}" dir="${classes.obf}">
      <arg value="a"/>
      <arg value="-tzip"/>
      <arg value="-mm=Deflate"/>
      <arg value="-mx9"/>
      <arg value="-mfb=258"/>
      <arg value="-mpass=15"/>
      <arg value="${jar.cmp}"/>
      <arg value="*"/>
    </exec>
  </target>

  <!-- Generates the final appliation JAR depending on the     -->
  <!-- availability of 7za.                                    -->
  <target name="compress" depends="obfuscate,check-7za,copy-obfuscated,compress-obfuscated"/>



  <!-- = Reports ============================================= -->
  <!-- ======================================================= -->
  <!-- Generates all meaningful reports in ${reports}.         -->
  <target name="reports" depends="clean,tools-reports,conf-reports,obfuscate,unit-test,similarity-test,findbugs"/>



  <!-- = JUnit management ==================================== -->
  <!-- ======================================================= -->

  <!-- Notifies user that unit tests are being skipped if      -->
  <!-- junit is not available.                                 -->
  <target name="skip-unit-test" unless="junit.available">
    <echo>JUnit not available, skipping test cases...</echo>
  </target>

  <!-- Runs all JUnit test cases and halts if one test fails.  -->
  <!-- Test cases are classes whose name ends with 'Test'.     -->
  <!-- A summary of all test cases is printed to the standard  -->
  <!-- Ant output and full reports are generated to disk       -->
  <!-- in the ${junit.reports} folder.                         -->
  <target name="do-unit-test" if="junit.available">
    <echo>Running test cases...</echo>
    <mkdir dir="${junit.reports}"/>
    <junit printsummary="yes" haltonfailure="yes">
      <formatter type="plain"/>
      <formatter type="xml"/>
      <classpath>
        <pathelement location="${classes.normal}"/>
        <fileset dir="${lib}">
          <include name="**/*.jar"/>
        </fileset>
      </classpath>
      <batchtest fork="yes" todir="${junit.reports}">
        <fileset dir="${classes.normal}">
          <include name="**/*Test.class"/>
        </fileset>
      </batchtest>
    </junit>
  </target>

  <!-- Runs JUnit test cases if junit is available.            -->
  <target name="unit-test" depends="jar,check-junit,skip-unit-test,do-unit-test"/>



  <!-- = Findbugs integration ================================ -->
  <!-- ======================================================= -->
  <!-- Notifies user that bytecode analysis is being skipped   -->
  <!-- if FindBugs is not available.                           -->
  <target name="skip-findbugs" unless="findbugs.available">
    <echo>FindBugs not available, skipping bytecode analysis...</echo>
  </target>

  <!-- Runs FindBugs bytecode analysis and stores the output   -->
  <!-- ${tmp.compile}/findbugs.xml.                            -->
  <target name="do-findbugs" depends="jar" if="findbugs.available">
    <echo>Analysing bytecode...</echo>
    <mkdir dir="${reports.main}"/>
    <echo file="${tmp.compile}/findbugs-filter.xml">
&lt;FindBugsFilter&gt;
  &lt;Match&gt;
    &lt;Package name="~com\.mucommander.*" /&gt;
  &lt;/Match&gt;
&lt;/FindBugsFilter&gt;
    </echo>

    <findbugs home="${findbugs.home}" output="xml" outputFile="${findbugs.reports}" jvmargs="-Xmx256m" effort="max"
              includefilter="${tmp.compile}/findbugs-filter.xml">
      <sourcePath path="${source}" />
      <class location="${jar.normal}"/>
      <auxclasspath>
        <fileset dir="${lib}/noinclude">
          <include name="**/*.jar"/>
        </fileset>
      </auxclasspath>
    </findbugs>
  </target>

  <!-- Runs FindBugs bytecode analysis if it's available.      -->
  <target name="findbugs" depends="load-findbugs,skip-findbugs,do-findbugs"/>



  <!-- = Simian integration (similarity checker) ============= -->
  <!-- ======================================================= -->

  <!-- Notifies user that unit tests are being skipped if      -->
  <!-- junit is not available.                                 -->
  <target name="skip-similarity-test" unless="simian.available">
    <echo>Simian not available, skipping similarity check...</echo>
  </target>

  <!-- Run similarity test                                     -->
  <target name="do-similarity-test" depends="load-simian" if="simian.available">
    <echo>Running similarity check...</echo>
    <mkdir dir="${reports.main}"/>
    <simian>
      <fileset dir="${source}" includes="**/*.java"/>
      <formatter type="plain" toFile="${simian.reports}"/>
    </simian>
  </target>

  <!-- Runs similarity test only if Simian is available.       -->
  <target name="similarity-test" depends="check-simian,skip-similarity-test,do-similarity-test"/>



  <!-- = Launch4j management ================================= -->
  <!-- ======================================================= -->
  <!-- The following targets are used to deal with launch4j's  -->
  <!-- availability.                                           -->
  <!-- Only 'load-launch4j' should be referenced, as the other -->
  <!-- targets are only helper ones.                           -->

  <!-- Checks whether launch4j is available.                   -->
  <!-- Output will be stored in ${launch4j.available}.         -->
  <!-- If the build is not in 'release' mode and Launch4j      -->
  <!-- isn't properly configured, this task will fail the      -->
  <!-- build.                                                  -->
  <target name="check-launch4j">
    <condition property="launch4j.available" value="true">
      <and>
        <available file="${launch4j.dir}" type="dir"/>
        <!-- If the property is defined but empty, it will     -->
        <!-- default to #{user.dir}. We must make sure this    -->
        <!-- doesn't happen.                                   -->
        <not>
          <equals arg1="${launch4j.dir}" arg2="${user.dir}" trim="true"/>
        </not>
      </and>
    </condition>

    <!-- If launch4j is not available and we're not in         -->
    <!-- release mode, we must fail the build here.            -->
    <fail message="Launch4j not configured">
      <condition>
        <and>
          <not>
            <istrue value="${is-release}"/>
          </not>
          <not>
            <istrue value="${launch4j.available}"/>
          </not>
        </and>
      </condition>
    </fail>
  </target>

  <!-- Loads the launch4j task if it's available.              -->
  <!-- If the operation was a success, ${launch4j.available}   -->
  <!-- will be set to true.                                    -->
  <target name="load-launch4j" depends="check-launch4j" if="launch4j.available">
    <taskdef name="launch4j" classname="net.sf.launch4j.ant.Launch4jTask" classpath="${launch4j.dir}/launch4j.jar:${launch4j.dir}/xstream.jar"/>
  </target>

  <!-- Checks whether nsis is available.                       -->
  <!-- Output is stored in ${nsis.available}.                  -->
  <!-- If the build is not in 'release' mode and NSIS isn't    -->
  <!-- properly configured, this task will fail the build.     -->
  <target name="check-nsis">
    <condition property="nsis.available" value="true">
      <and>
        <available file="${nsis.executable}" type="file"/>
      </and>
    </condition>

    <!-- If nsis is not available and we're not in release     -->
    <!-- mode, we must fail the build here.                    -->
    <fail message="NSIS not configured">
      <condition>
        <and>
          <not>
            <istrue value="${is-release}"/>
          </not>
          <not>
            <istrue value="${nsis.available}"/>
          </not>
        </and>
      </condition>
    </fail>
  </target>

  <!-- Checks whether it's possible to generate a setup.       -->
  <!-- Output will be stored in ${setup.available}.            -->
  <target name="check-setup" depends="load-launch4j,check-nsis">
    <condition property="setup.available" value="true">
      <and>
        <istrue value="${nsis.available}"/>
        <istrue value="${launch4j.available}"/>
      </and>
    </condition>
  </target>



  <!-- = Windows executable ================================== -->
  <!-- ======================================================= -->
  <!-- The following targets are used to create a Win32        -->
  <!-- executable file.                                        -->
  <!-- Only 'exe' should be referenced, as the other ones are  -->
  <!-- only helper targets.                                    -->

  <!-- Creates a Win32 executable and stores the output in     -->
  <!-- ${exe.file}.                                            -->
  <!-- This target will only be executed if launch4j is found  -->
  <!-- to be available.                                        -->
  <target name="make-exe" depends="compress" if="launch4j.available">
    <echo>Creating Win32 executable...</echo>
    <launch4j>
      <config outfile="${exe.file}" jarpath="mucommander.jar" icon="${nsis.icon}" dontwrapjar="true" chdir=".">
        <jre minversion="${app.jvm}.0" args="-Djava.system.class.loader=${app.loader}"/>
      </config>
    </launch4j>
  </target>

  <!-- Notifies the user that the executable file couldn't be  -->
  <!-- created for lack of Launch4j.                           -->
  <target name="skip-exe" unless="launch4j.available">
    <echo>Launch4j not available, skipping Win32 executable creation...</echo>
  </target>

  <!-- Creates a Win32 executable.                             -->
  <!-- This depends on launch4j being properly configured.     -->
  <!-- If it is, output will be stored in ${exe.file}.         -->
  <!-- Otherwise, this target will be skipped.                 -->
  <target name="exe" depends="load-launch4j,make-exe,skip-exe"/>



  <!-- = Windows setup ======================================= -->
  <!-- ======================================================= -->
  <!-- The following tasks are used to generate a Win32 setup. -->
  <!-- Only 'setup-exe' should be referenced, as the other     -->
  <!-- tasks are only helper ones.                             -->

  <!-- Creates a windows setup file and stores the output in   -->
  <!-- ${dist}/${package-prefix}.exe.                          -->
  <target name="make-setup" depends="package-prefix,exe" if="setup.available">
    <echo>Creating Win32 installer...</echo>

    <!-- Prepares the NSIS directory.                          -->
    <mkdir dir="${nsis.tmp}"/>
    <copy file="${exe.file}"             tofile="${nsis.tmp}/muCommander.exe" overwrite="true"/>
    <copy file="${jar.cmp}"              tofile="${nsis.tmp}/mucommander.jar" overwrite="true"/>
    <copy file="${nsis.icon}"            tofile="${nsis.tmp}/mucommander.ico" overwrite="true"/>

    <!-- Makes sure readme.txt and license.txt contain         -->
    <!-- proper windows linebreaks.                            -->
    <fixcrlf srcdir="." destdir="${nsis.tmp}" includes="readme.txt,license.txt" eol="crlf"/>

    <!-- Generates the NSIS script.                            -->
   <copy file="${nsis.script}" tofile="${nsis.tmp}/mucommander.nsi">
      <filterset>
        <filter token="MU_VERSION" value="${app.version}${app.subversion}"/>
        <filter token="MU_EXE"     value="muCommander.exe"/>
        <filter token="MU_JAR"     value="mucommander.jar"/>
        <filter token="MU_ICON"    value="mucommander.ico"/>
        <filter token="MU_OUT"     value="mucommander-setup.exe"/>
        <filter token="MU_README"  value="readme.txt"/>
        <filter token="MU_LICENSE" value="license.txt"/>
      </filterset>
   </copy>

    <!-- Generates the muCommander windows installer.          -->
    <exec executable="${nsis.executable}">
      <arg value="${nsis.tmp}/mucommander.nsi"/>
    </exec>

    <!-- Copies the installer in the dist folder.              -->
    <copy file="${nsis.tmp}/mucommander-setup.exe" tofile="${dist}/${package-prefix}-setup.exe" overwrite="true"/>
  </target>

  <!-- Notifies the user that the system is not properly       -->
  <!-- configured for setup generation.                        -->
  <target name="skip-setup" unless="setup.available">
    <echo>Setup generation unavailable, skipping...</echo>
  </target>

  <!-- Generates a Win32 setup and stores the output in        -->
  <!-- ${dist}/${package-prefix}-setup.exe.                    -->
  <target name="setup-exe" depends="check-setup,make-setup,skip-setup"/>



  <!-- = Debian package ====================================== -->
  <!-- ======================================================= -->

  <!-- Checks whether the JDeb task is available.              -->
  <!-- Output is stored in ${jdeb.available}.                  -->
  <target name="check-jdeb">
    <!-- If JDeb hasn't been properly configured, use default  -->
    <!-- values.                                               -->
    <property name="jdeb.lib"        location="${tools}/jdeb.jar"/>

    <!-- Checks whether JDeb is available.                     -->
    <condition property="jdeb.available" value="true">
      <available classname="org.vafer.jdeb.DebAntTask" classpath="${jdeb.lib}"/>
    </condition>

    <!-- If JDeb is not available and we're not in release     -->
    <!-- mode, we must fail the build here.                    -->
    <fail message="JDeb not configured">
      <condition>
        <and>
          <not>
            <istrue value="${is-release}"/>
          </not>
          <not>
            <istrue value="${jdeb.available}"/>
          </not>
        </and>
      </condition>
    </fail>
  </target>

  <!-- Loads the jdeb task if it's available.                  -->
  <!-- If it is, ${jdeb.available} will be set to true.        -->
  <target name="load-jdeb" depends="check-jdeb" if="jdeb.available">
    <taskdef name="jdeb" classname="org.vafer.jdeb.DebAntTask" classpath="${jdeb.lib}"/>
  </target>



  <!-- = MAC OS X packages =================================== -->
  <!-- ======================================================= -->
  <!-- The following targets are used to generate the OS X     -->
  <!-- release packages.                                       -->


  <!-- Packages the Mac OS X .app file in a tar.gz.            -->
  <!-- Note that this is a temporary target which will         -->
  <!-- probably disapear when we get around to generating      -->
  <!-- our own .dmg files from Ant.                            -->
  <target name="app.tgz" depends="app,archive-prefix,package-prefix">
    <echo>Packaging Mac OS X distribution file...</echo>
    <tar destfile="${dist}/${package-prefix}.app.tar.gz" compression="gzip">
      <tarfileset dir="${app.folder}" prefix="${archive-prefix}/${app.name}">
        <include name="**"/>
        <exclude name="**/JavaApplicationStub"/>
      </tarfileset>
      <tarfileset dir="${app.folder}" prefix="${archive-prefix}/${app.name}" mode="755">
        <include name="**/JavaApplicationStub"/>
      </tarfileset>
      <tarfileset file="${res.license}" prefix="${archive-prefix}"/>
      <tarfileset file="${res.readme}"  prefix="${archive-prefix}"/>
    </tar>
  </target>

   <!-- Generates a Mac OS X .app distribution of muCommander. -->
   <!-- Output will be stored in ${app.folder}.                -->
  <target name="app" depends="load-mkapp,compress">
    <echo>Creating Mac OS X application...</echo>
    <mkapp jar="${jar.cmp}" dest="${app.folder}" type="APPL" creator="MUCO" icon="${res}/icons/icon.icns"
           infoversion="0.9" classpath="/System/Library/Java">
      <string  name="CFBundleName"                    value="muCommander"/>
      <string  name="CFBundleVersion"                 value="${app.version}${app.subversion}"/>
      <boolean name="CFBundleAllowMixedLocalizations" value="true"/>
      <string  name="CFBundleDevelopmentRegion"       value="English"/>
      <string  name="CFBundleShortVersionString"      value="${app.version}${app.subversion}"/>
      <string  name="CFBundleGetInfoString"           value="muCommander ${app.version}${app.subversion}, (c) ${app.copyright} Maxence Bernard, ${url.homepage}"/>
      <string  name="CFBundleInfoDictionaryVersion"   value="6.0"/>
      <dict    name="Java">
        <string name="MainClass"  value="${app.main}"/>
        <string name="JVMVersion" value="${app.jvm}+"/>
        <dict name="Properties">
          <string name="java.system.class.loader"   value="${app.loader}"/>
          <string name="com.apple.smallTabs"        value="true"/>
          <string name="com.apple.hwaccel"          value="true"/>
          <string name="apple.laf.useScreenMenuBar" value="true"/>
	  <string name="file.encoding" value="UTF-8"/>
        </dict>
      </dict>
    </mkapp>
  </target>

  <!-- Generates a Mac OS X dmg distribution of muCommander.   -->
  <!-- This target currently does nothing. We're hopeful that, -->
  <!-- someday, some good soul will have the courage to embark -->
  <!-- on the selfless endehavour of untangling the Mac OS X   -->
  <!-- .dmg format. Until then however, this will stay empty.  -->
  <target name="dmg" depends="compress"/>



  <!-- = JNLP management ===================================== -->
  <!-- ======================================================= -->
  <!-- Checks whether the keystore password is available.      -->
  <!-- If it is, sets ${store.available} to true.      -->
  <target name="check-store">
    <condition property="store.available" value="true">
      <and>
        <isset property="store.pass"/>
        <not>
          <equals arg1="${store.pass}" arg2="" trim="true"/>
        </not>
      </and>
    </condition>

    <!-- If the keystored password is not available and we're  -->
    <!-- not in release mode, we must fail the build here.     -->
    <fail message="Keystore password not configured">
      <condition>
        <and>
          <not>
            <istrue value="${is-release}"/>
          </not>
          <not>
            <istrue value="${store.available}"/>
          </not>
        </and>
      </condition>
    </fail>
  </target>

  <!-- Signs the obfuscated jar file.                          -->
  <!-- Output will be stored in ${jar.signed}.                 -->
  <target name="sign" depends="check-store,compress" if="store.available">
    <echo>Creating signed JAR file...</echo>
    <signjar jar="${jar.cmp}" signedjar="${jar.signed}" alias="maxence" keystore="${res}/keystore"
             storepass="${store.pass}"/>
  </target>

  <!-- Generates the Java webstart descriptor.                 -->
  <!-- Output will be stored in ${dist}/mucommander.jnlp.      -->
  <target name="jnlp" depends="load-mkjnlp">
    <!-- Prepares the necessary tasks and properties.          -->
    <echo>Creating JNLP file...</echo>
    <property name="url.jnlp" value="${url.jnlp.normal}"/>

    <!-- Generates the JNLP file.                              -->
    <mkjnlp out="${dist}/${jnlp.file}" spec="1.0+" version="${app.version}${app.subversion}" codebase="${url.jnlp}" href="${jnlp.file}" allpermissions="true">
      <information homepage="${url.homepage}" title="muCommander" vendor="Maxence Bernard" offline="true">
        <description>A cross-platform file manager.</description>
        <description kind="short">A cross-platform file manager.</description>
        <icon href="${jnlp.icon}" />
      </information>
      <resources os="Mac OS X">
        <property name="com.apple.smallTabs" value="true"/>
        <property name="com.apple.hwaccel" value="true"/>
        <property name="apple.laf.useScreenMenuBar" value="true"/>
        <property name="file.encoding" value="UTF-8"/>
      </resources>
      <resources>
        <j2se version="${app.jvm}+"/>
        <jar  href="mucommander.jar"/>
      </resources>
      <applicationdesc main="${app.main}"/>
    </mkjnlp>
  </target>



  <!-- = Source package ====================================== -->
  <!-- ======================================================= -->
  <!-- The following tasks are used to generate the            -->
  <!-- muCommander source package.                             -->

  <!-- Generates a source release of muCommander.              -->
  <!-- Output will be stored in:                               -->
  <!-- ${dist}/${package-prefix}-src.tar.gz                    -->
  <target name="source" depends="clean,archive-prefix,package-prefix">
    <echo>Packaging sources...</echo>

    <!-- Generates the TGZ file.                               -->
    <mkdir dir="${dist}"/>
    <tar destfile="${dist}/${package-prefix}-src.tar.gz" compression="gzip">
      <tarfileset dir="." prefix="${archive-prefix}">
        <exclude name="${dist}/**"/>
        <exclude name="${tmp}/**"/>
        <exclude name="local.xml"/>
      </tarfileset>
    </tar>
  </target>



  <!-- = Documentation generation ============================ -->
  <!-- ======================================================= -->

  <!-- Generates a zip file with muCommander's API docs.       -->
  <!-- The output will be stored in ${doc.api-tgz}.            --> 
  <target name="api-doc-tgz" depends="api-doc,tools-doc,archive-prefix,package-prefix">
    <echo>Packaging API documentation...</echo>
    <mkdir dir="${dist}"/>
    <tar destfile="${dist}/${package-prefix}-docs.tar.gz" compression="gzip">
      <tarfileset dir="${doc.api}" prefix="${archive-prefix}"/>
    </tar>
  </target>

  <!-- Generates muCommander's API javadoc.                    -->
  <!-- Output is stored in ${doc.api}.                         -->
  <target name="api-doc" depends="constants">
    <echo>Creating API javadoc...</echo>
    <mkdir dir="${doc.api}"/>
    <javadoc destdir="${doc.api}" author="true" windowtitle="muCommander API" encoding="UTF-8" access="protected">
      <bottom>
         <![CDATA[
           <p>This file is part of <a href="http://www.mucommander.com" target="_top">muCommander</a> - Copyright (C) ${app.copyright} Maxence Bernard</p>
         ]]>
      </bottom>
      <classpath>
         <fileset dir="${lib}">
         <include name="**/*.jar"/>
         </fileset>
      </classpath>
      <!-- 'Static' sources, excluding the Ant tools and JUnit -->
      <!-- test cases.                                         -->
      <fileset dir="${source}">
        <patternset refid="non-test-sources"/>
        <exclude name="com/mucommander/ant/**"/>
      </fileset>

      <!-- Dynamically generated sources.                      -->
      <fileset dir="${tmp.source}"/>
    </javadoc>
  </target>



  <!-- = Portable version generation ========================= -->
  <!-- ======================================================= -->
  <!-- The following targets are used to generate              -->
  <!-- muCommander's 'portable' package.                       -->

  <!-- Generates the Win32 launcher for the portable version   -->
  <!-- of muCommander.                                         -->
  <!-- Note that this target will only be executed if Launch4j -->
  <!-- is available.                                           -->
  <!-- Output will be stored in ${portable.exe}.               -->
  <target name="portable-exe" depends="load-launch4j" if="launch4j.available">
    <echo>Creating Win32 launcher...</echo>
    <mkdir dir="${portable.tmp}"/>
    <launch4j>
      <config outfile="${portable.exe}" jarpath="mucommander.jar" icon="${nsis.icon}" dontwrapjar="true" jarargs="-p .mucommander" chdir=".">
        <jre minversion="${app.jvm}.0" args="Djava.system.class.loader=${app.loader}"/>
      </config>
    </launch4j>
  </target>

  <!-- Generates a 'portable' distribution version of          -->
  <!-- muCommander.                                            -->
  <!-- Output will be stored in                                -->
  <!-- ${dist}/${package-prefix}-portable.tar.gz               -->
  <target name="portable" depends="compress,portable-exe,archive-prefix,package-prefix">
    <echo>Packaging portable distribution file...</echo>

    <!-- Makes sure the muCommander startup scripts uses the   -->
    <!-- proper arguments.                                     -->
    <copy tofile="${portable.sh}" overwrite="true">
      <fileset file="${res}/mucommander.sh"/>
      <filterset>
        <filter token="ARGS" value="-p $0/../.mucommander"/>
        <filter token="JAVA_ARGS" value="-Djava.system.class.loader=${app.loader}"/>
      </filterset>
    </copy>

    <!-- Generates the TGZ file, keeping execution flags.      -->
    <tar destfile="${dist}/${package-prefix}-portable.tar.gz" compression="gzip">
      <tarfileset file="${portable.sh}"  prefix="${archive-prefix}" mode="755"/>
      <tarfileset file="${portable.exe}" prefix="${archive-prefix}"/>
      <tarfileset file="${res.license}"  prefix="${archive-prefix}"/>
      <tarfileset file="${res.readme}"   prefix="${archive-prefix}"/>
      <tarfileset file="${jar.cmp}"      prefix="${archive-prefix}"/>
    </tar>
  </target>



  <!-- = Unix specific releases ============================== -->
  <!-- ======================================================= -->
  <!-- The following targets are used to generate Unix         -->
  <!-- specific release files.                                 -->

  <!-- Generates a UNIX tar.gz distribution of muCommander.    -->
  <!-- Output will be stored in                                -->
  <!-- ${dist}/${package-prefix}.tar.gz.                       -->
  <target name="tgz" depends="compress,archive-prefix,package-prefix">
    <echo>Packaging Unix release file...</echo>

    <!-- Makes sure the muCommander startup script uses the    -->
    <!-- proper arguments.                                     -->
    <copy todir="${tmp}" overwrite="true">
      <fileset file="${res}/mucommander.sh"/>
      <filterset>
        <filter token="ARGS"      value=""/>
        <filter token="JAVA_ARGS" value="-Djava.system.class.loader=${app.loader}"/>
      </filterset>
    </copy>

    <!-- Generates the TGZ file, keeping execution flags.      -->
    <tar destfile="${dist}/${package-prefix}.tar.gz" compression="gzip">
      <tarfileset file="${tmp}/mucommander.sh" prefix="${archive-prefix}" mode="755"/>
      <tarfileset file="${res.license}"        prefix="${archive-prefix}"/>
      <tarfileset file="${res.readme}"         prefix="${archive-prefix}"/>
      <tarfileset file="${jar.cmp}"            prefix="${archive-prefix}"/>
    </tar>
  </target>

  <!-- Generates the debian version and file name for          -->
  <!-- nightly builds.                                         -->
  <target name="nightly-debian-names" depends="load-strreplace" if="is-nightly">
    <tstamp/>
    <strreplace from="${app.version}${app.subversion} ${DSTAMP}" to="deb.version" what="[ ]" with="-"/>
    <property name="deb.name" value="mucommander_current_all.deb"/>
  </target>

  <!-- Generates the debian version and file name for          -->
  <!-- non-nightly builds.                                     -->
  <target name="release-debian-names" depends="load-strreplace" unless="is-nightly">
    <strreplace from="${app.version}${app.subversion}" to="deb.version" what="[ ]" with="-"/>
    <property name="deb.name" value="mucommander_${deb.version}_all.deb"/>
  </target>

  <!-- Generates the muCommander debian package.               -->
  <!-- Output will be stored in ${dist}/${deb.name}.           -->
  <!-- This target will only be executed if JDeb is properly   -->
  <!-- configured.                                             -->
  <target name="make-deb" depends="load-mksize,compress" if="jdeb.available">
    <!-- Creates the required directories.                     -->
    <echo>Creating debian release file...</echo>
    <mkdir dir="${deb.tmp}"/>
    <mkdir dir="${deb.control}"/>
    <mkdir dir="${deb.data}"/>
    <mkdir dir="${deb.data}/usr/share/mucommander"/>

    <!-- Copies the debian data files.                         -->
    <copy todir="${deb.data}/usr/share/mucommander" overwrite="true">
      <fileset file="${res}/mucommander.sh"/>
      <filterset>
        <filter token="ARGS"      value=""/>
        <filter token="JAVA_ARGS" value="-Djava.system.class.loader=${app.loader}"/>
      </filterset>
    </copy>
    <copy todir="${deb.data}/usr/share/mucommander" overwrite="true">
      <fileset file="${res.license}"/>
      <fileset file="${res.readme}"/>
      <fileset file="${jar.cmp}"/>
    </copy>

    <!-- Generates the data.tar.gz file.                       -->
    <tar destfile="${deb.tmp}/data.tar.gz" compression="gzip">
      <tarfileset dir="${deb.data}">
        <include name="**"/>
        <exclude name="**/usr/share/mucommander/mucommander.sh"/>
      </tarfileset>
      <tarfileset dir="${deb.data}/" mode="755">
        <include name="**/usr/share/mucommander/mucommander.sh"/>
      </tarfileset>
    </tar>

    <!-- Computes the install size.                            -->
    <mksize name="deb.size">
      <fileset dir="${deb.data}"/>
    </mksize>

    <!-- Copies the debian control files.                      -->
    <copy todir="${deb.control}" overwrite="true">
      <fileset dir="${deb.res}"/>
      <filterset>
        <filter token="VERSION" value="${deb.version}"/>
        <filter token="SIZE" value="${deb.size}"/>
      </filterset>
    </copy>

    <!-- Generates the debian package.                         -->
    <jdeb destfile="${dist}/${deb.name}" control="${deb.control}">
      <data src="${deb.tmp}/data.tar.gz"/>
    </jdeb>
  </target>

  <!-- Notifies users that we cannot generate the deb package. -->
  <!-- This target should only be called if:                   -->
  <!-- - JDeb is not properly configured.                      -->
  <!-- - we're in 'release' mode (${is-release} is true).      -->
  <target name="skip-deb" unless="jdeb.available">
    <echo>JDeb unavailable, skipping .deb generation...</echo>
  </target>

  <!-- Generates the muCommander debian package.               -->
  <!-- Note that the proper execution of this target depends   -->
  <!-- on JDeb being properly configured on the system.        -->
  <!-- If it's not, depending on the kind of release we're     -->
  <!-- doing, the build will either fail or skip the debian    -->
  <!-- package generation.                                     -->
  <target name="deb" depends="load-jdeb,nightly-debian-names,release-debian-names,make-deb,skip-deb"/>



  <!-- = version.xml generation ============================== -->
  <!-- ======================================================= -->
  <!-- The following targets are used to generate the version  -->
  <!-- XML file.                                               -->

  <!-- Generates the muCommander's version.xml file.           -->
  <!-- Output will be stored in ${version-file}.               -->
  <target name="version">
    <echo>Creating version file...</echo>
    <tstamp/>
    <copy file="${res.version}" tofile="${version-file}">
      <filterset>
        <filter token="VERSION"      value="${app.version}${app.subversion}"/>
        <filter token="DATE"         value="${DSTAMP}"/>
        <filter token="DOWNLOAD_URL" value="${url.app-download}"/>
        <filter token="JAR_URL"      value="${url.jar}"/>
      </filterset>
    </copy>
  </target>


  <!-- = Interaction with the CVS repository ================= -->
  <!-- ======================================================= -->
  <!-- Brings the local project tree in sync with the          -->
  <!-- repository.                                             -->
  <target name="update">
    <cvs command="update -dP"/>
  </target>


  <!-- = Bulk release ======================================== -->
  <!-- ======================================================= -->
  <!-- The following targets are used to generate bulk         -->
  <!-- releases. They're essentially batches of all known      -->
  <!-- release files, using different flags depending on       -->
  <!-- whether we're generating an official release or a       -->
  <!-- nightly one.                                            -->

  <!-- Marks the current build as a 'release' one.             -->
  <!-- While in release mode, errors that would otherwise be   -->
  <!-- considered fatal will be ignored. For example, if it's  -->
  <!-- not possible to generate the debian package because     -->
  <!-- JDeb wasn't properly configured, release builds will    -->
  <!-- will just print a warning out and skip the              -->
  <!-- corresponding target, while normal ones will fail.      -->
  <target name="set-release" depends="disable-debug">
    <property name="is-release" value="true"/>
  </target>

  <!-- Disables debug instructions in the generated binaries.  -->
  <target name="disable-debug">
    <echo>Disabling debug...</echo>
    <property name="is-debug" value="false"/>
  </target>

  <!-- Sets the current build as a 'nightly' one.              -->
  <!-- This will impact:                                       -->
  <!-- - archive and package prefixes, which won't include the -->
  <!--   current version number.                               -->
  <!-- - some remote paths, such as the URL at which to        -->
  <!--   download the version.xml or signed JAR files.         -->
  <target name="set-nightly" depends="set-release">
    <echo>Marking the build as 'nightly'...</echo>
    <property name="version-url" value="${url.nightly-version}"/>
    <property name="is-nightly"  value="true"/>
    <property name="url.jnlp"    value="${url.jnlp.nightly}"/>
    <property name="url.jar"     value="${url.jar-nightly}/"/>
  </target>

  <!-- Generates all available release files.                  -->
  <!-- This target will also try and start the resulting JAR   -->
  <!-- to make sure it boots properly.                         -->
  <target name="all" depends="source,tools-release,conf-release,unit-test,tgz,setup-exe,deb,portable,version,sign,jnlp,app.tgz,api-doc-tgz">
    <java jar="${jar.cmp}" failonerror="true" fork="true">
      <arg value="--help"/>
    </java>
  </target>

  <!-- Generates all the available release files.              -->
  <!-- This target is meant for official releases. Nightly     -->
  <!-- releases are done by 'nightly'.                         -->
  <!-- Non-critical errors will be ignored by this target:     -->
  <!-- it will try to generate all the release files it can,   -->
  <!-- regardless of whether others failed.                    -->
  <target name="release" depends="set-release,all"/>

  <!-- Generates all the available release files in nightly    -->
  <!-- mode.                                                   -->
  <!-- This will impact:                                       -->
  <!-- - archive and package prefixes, which won't include the -->
  <!--   current version number.                               -->
  <!-- - some remote paths, such as the URL at which to        -->
  <!--   download the version.xml or signed JAR files.         -->
  <!-- Non-critical errors will be ignored by this target:     -->
  <!-- it will try to generate all the release files it can,   -->
  <!-- regardless of whether others failed.                    -->
  <target name="nightly" depends="set-nightly,all"/>



  <!-- = Application lauching tasks ========================== -->
  <!-- ======================================================= -->
  <!-- The following tasks are meant for development purposes  -->
  <!-- only, and are just shorcuts for starting muCommander in -->
  <!-- various special modes such as stress-test mode.         -->

  <!-- Launches muCommander in stress test mode, changing      -->
  <!-- current folder every second or so.                      -->
  <target name="stress-test" depends="compile,resources">
    <java classname="com.mucommander.StressTester" fork="true">
      <classpath>
        <pathelement location="${classes.normal}"/>
         <fileset dir="lib">
          <include name="**/*.jar"/>
         </fileset>
      </classpath>
    </java>
  </target>

  <!-- Runs the application from unpackaged binaries.          -->
  <target name="run" depends="compile,resources">
    <java classname="${app.main}" fork="true">
      <sysproperty key="java.system.class.loader" value="${app.loader}"/>
      <classpath>
        <pathelement location="${classes.normal}"/>
        <fileset dir="${lib}">
          <include name="**/*.jar"/>
        </fileset>
      </classpath>
    </java>
  </target>
</project>
